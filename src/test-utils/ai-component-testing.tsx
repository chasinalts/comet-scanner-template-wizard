import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { AIProvider } from "@/lib/aiService";
import { AITestingFramework, AITestScenario } from "./comet-test-framework";

// ============================================================================
// AI COMPONENT TESTING UTILITIES
// ============================================================================

export interface AIComponentTestConfig {
  component: React.ComponentType<any>;
  props: any;
  aiScenarios: AITestScenario[];
  expectedBehaviors: AIExpectedBehavior[];
}

export interface AIExpectedBehavior {
  scenario: string;
  trigger: (user: ReturnType<typeof userEvent.setup>) => Promise<void>;
  assertions: (container: HTMLElement) => Promise<void>;
  timeout?: number;
}

export class AIComponentTester {
  private config: AIComponentTestConfig;
  private user: ReturnType<typeof userEvent.setup>;

  constructor(config: AIComponentTestConfig) {
    this.config = config;
    this.user = userEvent.setup();
  }

  async runAllTests(): Promise<{
    passed: number;
    failed: number;
    results: AITestResult[];
  }> {
    const results: AITestResult[] = [];
    let passed = 0;
    let failed = 0;

    // Setup AI mocks
    AITestingFramework.setupAIMocks();
    AITestingFramework.addMultipleAIResponses(this.config.aiScenarios);

    for (const behavior of this.config.expectedBehaviors) {
      try {
        const result = await this.runSingleTest(behavior);
        results.push(result);

        if (result.success) {
          passed++;
        } else {
          failed++;
        }
      } catch (error) {
        results.push({
          scenario: behavior.scenario,
          success: false,
          error: error.message,
          duration: 0,
        });
        failed++;
      }
    }

    return { passed, failed, results };
  }

  private async runSingleTest(
    behavior: AIExpectedBehavior,
  ): Promise<AITestResult> {
    const startTime = Date.now();

    try {
      // Render component
      const { container } = render(
        React.createElement(this.config.component, this.config.props),
      );

      // Execute trigger
      await behavior.trigger(this.user);

      // Run assertions
      await behavior.assertions(container);

      return {
        scenario: behavior.scenario,
        success: true,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      return {
        scenario: behavior.scenario,
        success: false,
        error: error.message,
        duration: Date.now() - startTime,
      };
    }
  }
}

export interface AITestResult {
  scenario: string;
  success: boolean;
  error?: string;
  duration: number;
}

// ============================================================================
// AI PROVIDER TESTING UTILITIES
// ============================================================================

export class AIProviderTester {
  static async testProviderSelection(
    providers: AIProvider[],
    user: ReturnType<typeof userEvent.setup>,
  ): Promise<void> {
    for (const provider of providers) {
      // Find provider selector
      const selector = screen.getByRole("combobox", { name: /ai provider/i });

      // Select provider
      await user.selectOptions(selector, provider);

      // Verify selection
      await waitFor(() => {
        expect(selector).toHaveValue(provider);
      });

      // Verify provider-specific UI changes
      await this.verifyProviderSpecificUI(provider);
    }
  }

  static async testProviderFailover(
    primaryProvider: AIProvider,
    fallbackProvider: AIProvider,
    user: ReturnType<typeof userEvent.setup>,
  ): Promise<void> {
    // Setup primary provider to fail
    AITestingFramework.addAIResponse({
      provider: primaryProvider,
      functionType: "function",
      prompt: "test prompt",
      expectedResponse: { code: "", explanation: "" },
      shouldFail: true,
      errorMessage: "Primary provider failed",
    });

    // Setup fallback provider to succeed
    AITestingFramework.addAIResponse({
      provider: fallbackProvider,
      functionType: "function",
      prompt: "test prompt",
      expectedResponse: {
        code: "// Fallback generated code",
        explanation: "Generated by fallback provider",
      },
    });

    // Select primary provider
    const selector = screen.getByRole("combobox", { name: /ai provider/i });
    await user.selectOptions(selector, primaryProvider);

    // Trigger generation
    const generateButton = screen.getByRole("button", { name: /generate/i });
    await user.click(generateButton);

    // Verify fallback behavior
    await waitFor(() => {
      expect(screen.getByText(/fallback generated code/i)).toBeInTheDocument();
    });
  }

  private static async verifyProviderSpecificUI(
    provider: AIProvider,
  ): Promise<void> {
    switch (provider) {
      case "openai":
        // Verify OpenAI-specific UI elements
        await waitFor(() => {
          expect(screen.getByText(/gpt/i)).toBeInTheDocument();
        });
        break;

      case "claude":
        // Verify Claude-specific UI elements
        await waitFor(() => {
          expect(screen.getByText(/anthropic/i)).toBeInTheDocument();
        });
        break;

      case "gemini":
        // Verify Gemini-specific UI elements
        await waitFor(() => {
          expect(screen.getByText(/google/i)).toBeInTheDocument();
        });
        break;

      case "openrouter":
        // Verify OpenRouter-specific UI elements
        await waitFor(() => {
          expect(screen.getByText(/router/i)).toBeInTheDocument();
        });
        break;
    }
  }
}

// ============================================================================
// AI GENERATION TESTING UTILITIES
// ============================================================================

export class AIGenerationTester {
  static async testCodeGeneration(
    functionType: "ticker" | "name" | "function" | "scanner" | "custom",
    prompt: string,
    expectedCodePatterns: string[],
    user: ReturnType<typeof userEvent.setup>,
  ): Promise<void> {
    // Setup AI response
    AITestingFramework.addAIResponse({
      provider: "openai",
      functionType,
      prompt,
      expectedResponse: {
        code: this.generateExpectedCode(functionType, expectedCodePatterns),
        explanation: `Generated ${functionType} code`,
      },
    });

    // Enter prompt
    const promptInput = screen.getByRole("textbox", { name: /prompt/i });
    await user.clear(promptInput);
    await user.type(promptInput, prompt);

    // Trigger generation
    const generateButton = screen.getByRole("button", { name: /generate/i });
    await user.click(generateButton);

    // Verify loading state
    await waitFor(() => {
      expect(screen.getByText(/generating/i)).toBeInTheDocument();
    });

    // Verify generated code
    await waitFor(
      () => {
        const codeElement = screen.getByText(/generated code/i);
        expect(codeElement).toBeInTheDocument();

        // Verify code patterns
        expectedCodePatterns.forEach((pattern) => {
          expect(
            screen.getByText(new RegExp(pattern, "i")),
          ).toBeInTheDocument();
        });
      },
      { timeout: 10000 },
    );
  }

  static async testCodeValidation(
    generatedCode: string,
    expectedValidations: CodeValidation[],
  ): Promise<void> {
    for (const validation of expectedValidations) {
      const result = validation.validator(generatedCode);

      if (validation.shouldPass) {
        expect(result).toBe(true);
      } else {
        expect(result).toBe(false);
      }
    }
  }

  static async testErrorHandling(
    errorScenarios: AIErrorScenario[],
    user: ReturnType<typeof userEvent.setup>,
  ): Promise<void> {
    for (const scenario of errorScenarios) {
      // Setup error response
      AITestingFramework.addAIResponse({
        provider: scenario.provider,
        functionType: scenario.functionType,
        prompt: scenario.prompt,
        expectedResponse: { code: "", explanation: "" },
        shouldFail: true,
        errorMessage: scenario.expectedError,
      });

      // Trigger the scenario
      await scenario.trigger(user);

      // Verify error handling
      await waitFor(() => {
        expect(
          screen.getByText(new RegExp(scenario.expectedError, "i")),
        ).toBeInTheDocument();
      });

      // Verify recovery mechanism
      if (scenario.recoveryAction) {
        await scenario.recoveryAction(user);

        await waitFor(() => {
          expect(
            screen.queryByText(new RegExp(scenario.expectedError, "i")),
          ).not.toBeInTheDocument();
        });
      }
    }
  }

  private static generateExpectedCode(
    functionType: string,
    patterns: string[],
  ): string {
    const baseCode = `//@version=5
indicator("AI Generated ${functionType}", overlay=true)

// Generated code for ${functionType}
`;

    return baseCode + patterns.join("\n");
  }
}

export interface CodeValidation {
  name: string;
  validator: (code: string) => boolean;
  shouldPass: boolean;
}

export interface AIErrorScenario {
  provider: AIProvider;
  functionType: "ticker" | "name" | "function" | "scanner" | "custom";
  prompt: string;
  expectedError: string;
  trigger: (user: ReturnType<typeof userEvent.setup>) => Promise<void>;
  recoveryAction?: (user: ReturnType<typeof userEvent.setup>) => Promise<void>;
}

// ============================================================================
// AI PERFORMANCE TESTING UTILITIES
// ============================================================================

export class AIPerformanceTester {
  static async measureGenerationTime(
    scenarios: AITestScenario[],
    iterations: number = 5,
  ): Promise<PerformanceMetrics> {
    const metrics: PerformanceMetrics = {
      averageTime: 0,
      minTime: Infinity,
      maxTime: 0,
      successRate: 0,
      results: [],
    };

    for (const scenario of scenarios) {
      const scenarioResults: number[] = [];
      let successCount = 0;

      for (let i = 0; i < iterations; i++) {
        const startTime = performance.now();

        try {
          AITestingFramework.addAIResponse(scenario);

          // Simulate AI call
          const response = await fetch("/api/ai/generate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              provider: scenario.provider,
              functionType: scenario.functionType,
              prompt: scenario.prompt,
            }),
          });

          if (response.ok) {
            successCount++;
          }

          const endTime = performance.now();
          const duration = endTime - startTime;
          scenarioResults.push(duration);

          metrics.minTime = Math.min(metrics.minTime, duration);
          metrics.maxTime = Math.max(metrics.maxTime, duration);
        } catch (error) {
          // Handle error
          scenarioResults.push(0);
        }
      }

      metrics.results.push({
        scenario: `${scenario.provider}-${scenario.functionType}`,
        times: scenarioResults,
        successRate: successCount / iterations,
      });
    }

    // Calculate overall metrics
    const allTimes = metrics.results.flatMap((r) =>
      r.times.filter((t) => t > 0),
    );
    metrics.averageTime =
      allTimes.reduce((sum, time) => sum + time, 0) / allTimes.length;
    metrics.successRate =
      metrics.results.reduce((sum, r) => sum + r.successRate, 0) /
      metrics.results.length;

    return metrics;
  }

  static async testConcurrentGenerations(
    scenarios: AITestScenario[],
    concurrency: number = 3,
  ): Promise<ConcurrencyTestResult> {
    const startTime = performance.now();

    // Setup all scenarios
    scenarios.forEach((scenario) => AITestingFramework.addAIResponse(scenario));

    // Create concurrent promises
    const promises = scenarios
      .slice(0, concurrency)
      .map(async (scenario, index) => {
        const requestStartTime = performance.now();

        try {
          const response = await fetch("/api/ai/generate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              provider: scenario.provider,
              functionType: scenario.functionType,
              prompt: scenario.prompt,
            }),
          });

          const requestEndTime = performance.now();

          return {
            index,
            success: response.ok,
            duration: requestEndTime - requestStartTime,
            response: await response.json(),
          };
        } catch (error) {
          return {
            index,
            success: false,
            duration: performance.now() - requestStartTime,
            error: error.message,
          };
        }
      });

    const results = await Promise.all(promises);
    const endTime = performance.now();

    return {
      totalDuration: endTime - startTime,
      concurrency,
      results,
      successRate: results.filter((r) => r.success).length / results.length,
    };
  }
}

export interface PerformanceMetrics {
  averageTime: number;
  minTime: number;
  maxTime: number;
  successRate: number;
  results: Array<{
    scenario: string;
    times: number[];
    successRate: number;
  }>;
}

export interface ConcurrencyTestResult {
  totalDuration: number;
  concurrency: number;
  results: Array<{
    index: number;
    success: boolean;
    duration: number;
    response?: any;
    error?: string;
  }>;
  successRate: number;
}

// ============================================================================
// EXPORT ALL UTILITIES
// ============================================================================

export {
  AITestingFramework,
  AIComponentTester,
  AIProviderTester,
  AIGenerationTester,
  AIPerformanceTester,
};
